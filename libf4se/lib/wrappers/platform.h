// Generated by Claude (Anthropic AI) to fix autocxx Windows type issues
// Date: May 23, 2025

#pragma once

/*
 * platform_types.h - Windows types for cross-platform development
 * 
 * Purpose:
 * This header lets you compile Windows-specific code on Linux (or any non-Windows platform).
 * It's mainly for generating Rust bindings with autocxx - you develop on Linux, but your
 * code will eventually run on Windows.
 * 
 * Why this approach?
 * - autocxx needs to parse C++ headers to generate bindings
 * - Including real windows.h on Linux = compile errors everywhere
 * - We define Windows types as simple C types that autocxx can understand
 * - When you compile on Windows later, just use the real windows.h
 * 
 * Design choices:
 * - Keep it SIMPLE - autocxx doesn't like complex C++ features
 * - No unions (autocxx hates them) - we use simple structs instead
 * - No inline functions with complex bodies - just simple stubs
 * - All handles are just void* - that's what they are anyway
 * - Mock functions return safe defaults (NULL, FALSE, 0)
 * 
 * Usage:
 * Just include this before any Windows-specific headers when building on Linux.
 * Your build.rs can define GENERATING_RUST_BINDINGS to get even simpler types.
 */

#ifdef _WIN32
    // On Windows? Use the real deal
    #include <windows.h>
#else
    // On Linux/Mac/etc? Here's our mock Windows environment

#ifdef __cplusplus
extern "C" {
#endif

    /* ========================================================================
     * Basic Handle Types
     * All Windows handles are essentially opaque pointers, so void* works fine
     * ======================================================================== */
    
    typedef void* HANDLE;
    typedef HANDLE HMODULE;
    typedef HANDLE HINSTANCE;
    typedef HANDLE HWND;
    typedef HANDLE HKEY;
    typedef HANDLE HFILE;
    typedef HANDLE HDC;
    typedef HANDLE HGDIOBJ;
    typedef HANDLE HFONT;
    typedef HANDLE HPEN;
    typedef HANDLE HBRUSH;
    typedef HANDLE HPALETTE;
    typedef HANDLE HBITMAP;
    typedef HANDLE HICON;
    typedef HANDLE HCURSOR;
    typedef HANDLE HRGN;
    typedef HANDLE HMENU;
    typedef HANDLE HGLOBAL;
    typedef HANDLE HLOCAL;
    typedef HANDLE HRSRC;
    typedef HANDLE HDESK;
    typedef HANDLE HWINSTA;
    typedef HANDLE HKL;
    typedef HANDLE HMONITOR;
    typedef HANDLE HTHREAD;
    typedef HANDLE HPROCESS;
    typedef HANDLE HEVENT;
    typedef HANDLE HSEMAPHORE;
    typedef HANDLE HTIMER;
    typedef HANDLE HFILEMAPPING;
    
    // Special handle that's actually a long on Windows
    typedef long HRESULT;
    
    /* ========================================================================
     * Basic Integer Types
     * These match Windows sizes exactly
     * ======================================================================== */
    
    typedef unsigned long DWORD;
    typedef unsigned long long DWORD64;
    typedef unsigned long DWORD32;
    typedef int BOOL;
    typedef unsigned char BYTE;
    typedef unsigned short WORD;
    typedef short SHORT;
    typedef long LONG;
    typedef long long LONGLONG;
    typedef unsigned long ULONG;
    typedef unsigned long long ULONGLONG;
    typedef unsigned long ULONG32;
    typedef unsigned long long ULONG64;
    typedef int INT;
    typedef unsigned int UINT;
    typedef unsigned int UINT32;
    typedef unsigned long long UINT64;
    typedef int INT32;
    typedef long long INT64;
    
    /* ========================================================================
     * Pointer-sized Types
     * These change size between 32-bit and 64-bit builds
     * ======================================================================== */
    
    #ifdef _WIN64
        typedef long long INT_PTR;
        typedef unsigned long long UINT_PTR;
        typedef long long LONG_PTR;
        typedef unsigned long long ULONG_PTR;
        typedef unsigned long long DWORD_PTR;
    #else
        typedef int INT_PTR;
        typedef unsigned int UINT_PTR;
        typedef long LONG_PTR;
        typedef unsigned long ULONG_PTR;
        typedef unsigned long DWORD_PTR;
    #endif
    
    // Size types - these are pointer-sized
    typedef ULONG_PTR SIZE_T;
    typedef LONG_PTR SSIZE_T;
    typedef SIZE_T* PSIZE_T;
    
    /* ========================================================================
     * Character Types
     * Windows has both ANSI and Unicode APIs
     * ======================================================================== */
    
    typedef char CHAR;
    typedef wchar_t WCHAR;
    typedef CHAR* PCHAR;
    typedef WCHAR* PWCHAR;
    typedef unsigned char UCHAR;
    typedef unsigned short USHORT;
    
    // String pointers - 'LP' means 'Long Pointer' (historical from 16-bit days)
    typedef const char* LPCSTR;
    typedef const char* PCSTR;
    typedef char* LPSTR;
    typedef char* PSTR;
    typedef const wchar_t* LPCWSTR;
    typedef const wchar_t* PCWSTR;
    typedef wchar_t* LPWSTR;
    typedef wchar_t* PWSTR;
    
    // Generic text that switches between ANSI/Unicode
    #ifdef UNICODE
        typedef WCHAR TCHAR;
        typedef LPCWSTR LPCTSTR;
        typedef LPWSTR LPTSTR;
    #else
        typedef char TCHAR;
        typedef LPCSTR LPCTSTR;
        typedef LPSTR LPTSTR;
    #endif
    
    /* ========================================================================
     * Other Pointer Types
     * Windows loves its pointer typedefs
     * ======================================================================== */
    
    typedef void* LPVOID;
    typedef void* PVOID;
    typedef const void* LPCVOID;
    typedef const void* PCVOID;
    typedef DWORD* LPDWORD;
    typedef DWORD* PDWORD;
    typedef WORD* LPWORD;
    typedef LONG* LPLONG;
    typedef BYTE* LPBYTE;
    typedef BYTE* PBYTE;
    typedef BOOL* LPBOOL;
    typedef INT* LPINT;
    typedef INT* PINT;
    typedef UINT* PUINT;
    
    // Numeric types
    #ifndef _FLOAT_DEFINED
    #define _FLOAT_DEFINED
        typedef float FLOAT;
    #endif
    typedef FLOAT* PFLOAT;
    
    /* ========================================================================
     * Special Types
     * ======================================================================== */
    
    // Function result types
    typedef UINT_PTR WPARAM;
    typedef LONG_PTR LPARAM;
    typedef LONG_PTR LRESULT;
    
    // Colors and access masks
    typedef DWORD COLORREF;
    typedef DWORD* LPCOLORREF;
    typedef DWORD ACCESS_MASK;
    typedef ACCESS_MASK* PACCESS_MASK;
    typedef ACCESS_MASK REGSAM;
    
    // Locale types
    typedef DWORD LCID;
    typedef DWORD* PLCID;
    typedef WORD LANGID;
    typedef DWORD LCTYPE;
    
    // Atom (for registered window classes, etc)
    typedef WORD ATOM;
    
    /* ========================================================================
     * Large Integer Support
     * Simplified for autocxx - no unions!
     * ======================================================================== */
    
    typedef struct _LARGE_INTEGER {
        LONGLONG QuadPart;
    } LARGE_INTEGER, *PLARGE_INTEGER;
    
    typedef struct _ULARGE_INTEGER {
        ULONGLONG QuadPart;
    } ULARGE_INTEGER, *PULARGE_INTEGER;
    
    /* ========================================================================
     * Common Structures
     * Only the essential ones that autocxx can handle
     * ======================================================================== */
    
    typedef struct tagRECT {
        LONG left;
        LONG top;
        LONG right;
        LONG bottom;
    } RECT, *PRECT, *LPRECT;
    typedef const RECT* LPCRECT;
    
    typedef struct tagPOINT {
        LONG x;
        LONG y;
    } POINT, *PPOINT, *LPPOINT;
    
    typedef struct tagSIZE {
        LONG cx;
        LONG cy;
    } SIZE, *PSIZE, *LPSIZE;
    
    typedef struct tagMSG {
        HWND hwnd;
        UINT message;
        WPARAM wParam;
        LPARAM lParam;
        DWORD time;
        POINT pt;
        #ifdef GENERATING_RUST_BINDINGS
        DWORD lPrivate;  // Keep it simple for autocxx
        #else
        DWORD lPrivate;
        #endif
    } MSG, *PMSG, *LPMSG;
    
    typedef struct _SECURITY_ATTRIBUTES {
        DWORD nLength;
        LPVOID lpSecurityDescriptor;
        BOOL bInheritHandle;
    } SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;
    
    typedef struct _FILETIME {
        DWORD dwLowDateTime;
        DWORD dwHighDateTime;
    } FILETIME, *PFILETIME, *LPFILETIME;
    
    typedef struct _SYSTEMTIME {
        WORD wYear;
        WORD wMonth;
        WORD wDayOfWeek;
        WORD wDay;
        WORD wHour;
        WORD wMinute;
        WORD wSecond;
        WORD wMilliseconds;
    } SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;
    
    /* ========================================================================
     * Function Pointer Types
     * Simplified for autocxx - just void* if generating bindings
     * ======================================================================== */
    
    #ifdef GENERATING_RUST_BINDINGS
        // autocxx doesn't like complex function pointers
        typedef void* WNDPROC;
        typedef void* DLGPROC;
        typedef void* TIMERPROC;
        typedef void* FARPROC;
        typedef void* NEARPROC;
        typedef void* PROC;
    #else
        // Real function pointer types for C++ code
        typedef LRESULT (*WNDPROC)(HWND, UINT, WPARAM, LPARAM);
        typedef INT_PTR (*DLGPROC)(HWND, UINT, WPARAM, LPARAM);
        typedef void (*TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);
        #ifdef _WIN64
            typedef INT_PTR (*FARPROC)(void);
            typedef INT_PTR (*NEARPROC)(void);
            typedef INT_PTR (*PROC)(void);
        #else
            typedef int (*FARPROC)(void);
            typedef int (*NEARPROC)(void);
            typedef int (*PROC)(void);
        #endif
    #endif
    
    /* ========================================================================
     * Critical Section
     * Simplified - just an opaque structure
     * ======================================================================== */
    
    typedef struct _RTL_CRITICAL_SECTION {
        PVOID Reserved1;
        LONG Reserved2;
        LONG Reserved3;
        PVOID Reserved4;
        PVOID Reserved5;
        ULONG_PTR Reserved6;
    } RTL_CRITICAL_SECTION, CRITICAL_SECTION, *PCRITICAL_SECTION, *LPCRITICAL_SECTION;
    
    /* ========================================================================
     * Constants
     * The usual suspects
     * ======================================================================== */
    
    // Basics - check if defined to avoid redefinition errors
    #ifndef NULL
        #ifdef __cplusplus
            #define NULL 0
        #else
            #define NULL ((void*)0)
        #endif
    #endif
    
    #ifndef FALSE
        #define FALSE 0
    #endif
    
    #ifndef TRUE
        #define TRUE 1
    #endif
    
    // Invalid values
    #define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
    #define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFF)
    #define INVALID_SET_FILE_POINTER ((DWORD)-1)
    #define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
    
    // Limits
    #define MAX_PATH 260
    #define INFINITE 0xFFFFFFFF
    
    // Wait results
    #define WAIT_TIMEOUT 258L
    #define WAIT_FAILED ((DWORD)0xFFFFFFFF)
    
    // Common errors
    #define ERROR_SUCCESS 0L
    #define ERROR_INVALID_HANDLE 6L
    #define ERROR_NOT_ENOUGH_MEMORY 8L
    #define ERROR_INVALID_PARAMETER 87L
    #define ERROR_INSUFFICIENT_BUFFER 122L
    
    // Calling conventions - these do nothing on non-Windows
    #define WINAPI
    #define CALLBACK
    #define PASCAL
    #define APIENTRY
    #define STDCALL
    #define FASTCALL
    #define CDECL
    
    // Declspecs - also do nothing
    #define DECLSPEC_IMPORT
    #define DECLSPEC_EXPORT
    #define DECLSPEC_NORETURN
    
    // Other common macros
    #define CONST const
    #define VOID void
    
    // Byte extraction
    #define LOBYTE(w) ((BYTE)(((DWORD_PTR)(w)) & 0xff))
    #define HIBYTE(w) ((BYTE)((((DWORD_PTR)(w)) >> 8) & 0xff))
    #define LOWORD(l) ((WORD)(((DWORD_PTR)(l)) & 0xffff))
    #define HIWORD(l) ((WORD)((((DWORD_PTR)(l)) >> 16) & 0xffff))
    
    // Making values
    #define MAKEWORD(a, b) ((WORD)(((BYTE)(((DWORD_PTR)(a)) & 0xff)) | ((WORD)((BYTE)(((DWORD_PTR)(b)) & 0xff))) << 8))
    #define MAKELONG(a, b) ((LONG)(((WORD)(((DWORD_PTR)(a)) & 0xffff)) | ((DWORD)((WORD)(((DWORD_PTR)(b)) & 0xffff))) << 16))
    
    // Text macro
    #ifndef TEXT
        #ifdef UNICODE
            #define TEXT(quote) L##quote
        #else
            #define TEXT(quote) quote
        #endif
    #endif
    
    // For your STATIC_ASSERT issue
    #ifndef __COUNTER__
        #define __COUNTER__ __LINE__
    #endif

    // Modifier macros
    #ifndef CONST
        #define CONST const
    #endif
    
    #ifndef VOID
        #define VOID void
    #endif

    // Calling conventions (no-op on non-Windows)
    #ifndef WINAPI
        #define WINAPI
    #endif
    
    #ifndef CALLBACK
        #define CALLBACK
    #endif
    
    #ifndef PASCAL
        #define PASCAL
    #endif
    
    #ifndef APIENTRY
        #define APIENTRY
    #endif
    
    #ifndef APIPRIVATE
        #define APIPRIVATE
    #endif
    
    #ifndef STDCALL
        #define STDCALL
    #endif
    
    #ifndef FASTCALL
        #define FASTCALL
    #endif
    
    #ifndef CDECL
        #define CDECL
    #endif
    
    #ifndef DECLSPEC_IMPORT
        #define DECLSPEC_IMPORT
    #endif
    
    #ifndef DECLSPEC_EXPORT
        #define DECLSPEC_EXPORT
    #endif
    
    #ifndef DECLSPEC_NORETURN
        #define DECLSPEC_NORETURN
    #endif

    // ================================================================= //

    // Wrapper for _MESSAGE
    #ifndef _MESSAGE
        #define _MESSAGE(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
    #endif

    // Clang have issues with __forceinline, so we need to mock it
    #ifndef __forceinline
        #define __forceinline __attribute__((always_inline)) inline
    #endif
   
    #ifndef FORCEINLINE
        #define FORCEINLINE __forceinline
    #endif

    #define ALIGN(x) [[gnu::aligned(x)]]

    #define __declspec(x)

    /* ========================================================================
     * Mock Functions
     * These just return safe defaults - the real functions won't be called on Linux
     * Using static inline to avoid multiple definition errors
     * ======================================================================== */
    
    // Module functions
    static inline HMODULE LoadLibraryA(LPCSTR name) { (void)name; return NULL; }
    static inline HMODULE LoadLibraryW(LPCWSTR name) { (void)name; return NULL; }
    static inline HMODULE LoadLibraryExA(LPCSTR name, HANDLE file, DWORD flags) { 
        (void)name; (void)file; (void)flags; return NULL; 
    }
    static inline HMODULE LoadLibraryExW(LPCWSTR name, HANDLE file, DWORD flags) { 
        (void)name; (void)file; (void)flags; return NULL; 
    }
    static inline BOOL FreeLibrary(HMODULE module) { (void)module; return FALSE; }
    static inline FARPROC GetProcAddress(HMODULE module, LPCSTR name) { 
        (void)module; (void)name; return NULL; 
    }
    static inline HMODULE GetModuleHandleA(LPCSTR name) { (void)name; return NULL; }
    static inline HMODULE GetModuleHandleW(LPCWSTR name) { (void)name; return NULL; }
    
    // Error handling
    static inline DWORD GetLastError(void) { return 0; }
    static inline void SetLastError(DWORD error) { (void)error; }
    
    // Process/Thread
    static inline DWORD GetCurrentProcessId(void) { return 1; }
    static inline DWORD GetCurrentThreadId(void) { return 1; }
    static inline HANDLE GetCurrentProcess(void) { return (HANDLE)1; }
    static inline HANDLE GetCurrentThread(void) { return (HANDLE)1; }
    
    // Handle operations
    static inline BOOL CloseHandle(HANDLE handle) { (void)handle; return TRUE; }
    
    // Synchronization
    static inline DWORD WaitForSingleObject(HANDLE handle, DWORD milliseconds) { 
        (void)handle; (void)milliseconds; return WAIT_TIMEOUT; 
    }
    static inline DWORD WaitForMultipleObjects(DWORD count, const HANDLE* handles, 
                                               BOOL waitAll, DWORD milliseconds) { 
        (void)count; (void)handles; (void)waitAll; (void)milliseconds; 
        return WAIT_TIMEOUT; 
    }
    static inline void Sleep(DWORD milliseconds) { (void)milliseconds; }
    
    // Timing
    static inline DWORD GetTickCount(void) { return 0; }
    static inline ULONGLONG GetTickCount64(void) { return 0; }
    static inline BOOL QueryPerformanceCounter(LARGE_INTEGER* counter) { 
        (void)counter; return FALSE; 
    }
    static inline BOOL QueryPerformanceFrequency(LARGE_INTEGER* frequency) { 
        (void)frequency; return FALSE; 
    }
    
    // Memory - basic stubs
    static inline LPVOID VirtualAlloc(LPVOID addr, SIZE_T size, DWORD allocType, DWORD protect) {
        (void)addr; (void)size; (void)allocType; (void)protect; return NULL;
    }
    static inline BOOL VirtualFree(LPVOID addr, SIZE_T size, DWORD freeType) {
        (void)addr; (void)size; (void)freeType; return FALSE;
    }
    static inline HANDLE GetProcessHeap(void) { return (HANDLE)1; }
    static inline LPVOID HeapAlloc(HANDLE heap, DWORD flags, SIZE_T size) {
        (void)heap; (void)flags; (void)size; return NULL;
    }
    static inline BOOL HeapFree(HANDLE heap, DWORD flags, LPVOID mem) {
        (void)heap; (void)flags; (void)mem; return FALSE;
    }
    
    // Critical sections - no-ops
    static inline void InitializeCriticalSection(LPCRITICAL_SECTION cs) { (void)cs; }
    static inline void DeleteCriticalSection(LPCRITICAL_SECTION cs) { (void)cs; }
    static inline void EnterCriticalSection(LPCRITICAL_SECTION cs) { (void)cs; }
    static inline void LeaveCriticalSection(LPCRITICAL_SECTION cs) { (void)cs; }
    static inline BOOL TryEnterCriticalSection(LPCRITICAL_SECTION cs) { (void)cs; return TRUE; }


    // Fixes for f4se/GameTypes.h
    static inline void* FormHeap_Allocate(INT32 in) { (void)in; return NULL; }
    static inline void FormHeap_Free(void* in) { (void)in; return; }


#ifdef __cplusplus
}
#endif




#endif // _WIN32
